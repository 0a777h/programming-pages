<div class="ui inverted large menu">
<div class="item" style="padding-top: 1.6em;">
{% include elements/search.html %}
</div>
</div>

{% assign log = '' | split: '' %}

<div class="ui fitted inverted divider"></div>

{% assign collection_list = site.collections %}

{% assign ordered = '' | split: '' %}
{% assign unorder = '' | split: '' %}
{% for collection in collection_list %}
{% unless collection.label == 'posts' or collection.docs.size == 0 %}
{% if collection.tab-order %}{% assign ordered = ordered | push: collection %}
{% else %}{% assign unorder = unorder | push: collection %}
{% endif %}
{% endunless %}
{% endfor %}
{% assign ordered = ordered | sort: 'tab-order' %}
{% assign collection_list = ordered | concat: unorder %}

<div id="collection-tabs" class="ui inverted stackable pointing secondary menu">
{% for collection in collection_list %}
{% unless collection.label == 'posts' or collection.docs.size == 0 %}
{% capture tab_class %}{% if forloop.first %}active {% endif %}item{% endcapture %}
  <a class="{{ tab_class }}" data-tab="{{ collection.label | downcase }}">{{ collection.title }}</a>
{% endunless %}
{% endfor %}
</div>

{% for collection in collection_list %}
{% capture tab_class %}ui {% if forloop.first %}active {% endif %}inverted tab segment{% endcapture %}
<div class="{{ tab_class }}" data-tab="{{ collection.label | downcase }}">
<h4 class="ui header">{{ collection.title }}</h4>
<div class="ui inverted link list">
{% assign doc_list = collection.docs %}

{% if collection.label == 'guides' %}
{% assign guide_list = '' | split: '' %}

{%- comment %}
for guides, we want to support user-defined ordering, but not require it in every guide.

this means we have to create our own file tree, keeping children with parents as we re-sort
the collection list from its default alphabetical order into user order, and for that,
we want to perform a depth-first iterative visitation of the page tree.

here's a psuedocode implementation in a javascript-like language; given root:

  curr = root;
  stack = [];
  stack.push(root);
  while (stack.length > 0) {
    if (curr) {
      print(curr);

      if (curr.sibling)
        stack.push(curr.sibling);

      curr = curr.child;
    }
    else
      curr = stack.pop();
  }

but liquid brings some interesting challenges:
- no while loops
- no infinite loops
- no custom objects or hashes, just ordered arrays
- no array mutation in place
- no actual tree structure to start with, just a list of docs

so our strategy is to:
- start by bucketing the docs into levels, to get a tree-like context
  - levels correspond to 'generations', but not always parent-child links
    - parent-child relationships have to be tested by comparing path segments
  - items in the same level are of the same generation, but not always siblings
    - sibling relationships have to be tested by comparing path segments
- use arrays for tree nodes so we can store state (a 2-tuple: level index, item index)
- push state onto a stack made of an array and the push/pop operations from jekyll
- use a pseudo-infinite range loop with large bounds and a break clause in place of a while loop
{% endcomment -%}

{%- comment %} first, calculate max_depth as deepest level index {% endcomment -%}
{% assign max_depth = 0 %}
{% for doc in doc_list %}
  {% assign depth = doc.path | split:'/' | size | minus:2 %} {%- comment %} minus one to convert from length to index, minus two to ignore root collection directory (_guides/) {% endcomment -%}
  {% if depth > max_depth %}{% assign max_depth = depth %}{% endif %}
{% endfor %}

{%- comment %} separate docs into levels, and sort by user-defined order value {% endcomment -%}
{% assign leveled = '' | split: '' %}
{% for i in (0..max_depth) %}
  {% assign new = '' | split: '' %}
  {% assign ordered = '' | split: '' %}
  {% assign unorder = '' | split: '' %}
  {% for doc in doc_list %}
    {% assign depth = doc.path | split:'/' | size | minus:2 %}
    {% if depth == i %}
      {% if doc.order %}{% assign ordered = ordered | push: doc %}
      {% else %}{% assign unorder = unorder | push: doc %}
      {% endif %}
    {% endif %}
  {% endfor %}
  {% assign ordered = ordered | sort: 'order' %}
  {% assign new = ordered | concat: unorder %}
  {% assign leveled = leveled | push: new %}
{% endfor %}

{%- comment %} set root and make current be root {% endcomment -%}
{%- assign root = '' | split: '' -%}
{%- assign root = root | push: 0 -%} {%- comment %} level index {% endcomment -%}
{%- assign root = root | push: 0 -%} {%- comment %} group index {% endcomment -%}
{%- assign curr = root -%}
{%- comment %} create a stack and initialize it with the root node {% endcomment -%}
{%- assign stack = '' | split: '' -%}
{%- assign stack = stack | push: root -%}

{%- comment %} fake a while loop with a fake infinite loop, being sure to bail when all nodes are processed {% endcomment -%}
{%- assign enough = doc_list.size | times: 2 -%} {%- comment %} estimate the worst case number of iterations required {% endcomment -%}
{%- for ever in (0..enough) -%}
{%- assign ever_last = ever -%}
{%- if stack.size == 0 %}{%- capture log_entry -%}"(done)"{%- endcapture -%}{%- assign log = log | push: log_entry -%}{% break %}{% endif -%}
  {%- comment %} if we have a current node, record it, push next sibling on the stack, and move on to first child {% endcomment -%}
  {%- if curr -%}
    {%- comment %} print curr {% endcomment -%}
    {%- assign l = curr[0] -%}                       {%- comment %} level {% endcomment -%}
    {%- assign e = curr[1] -%}                       {%- comment %} entry {% endcomment -%}
    {%- assign d = leveled[l][e] -%}                 {%- comment %} doc {% endcomment -%}
    {%- assign p = d.path | split: '/' -%}           {%- comment %} path parts {% endcomment -%}
    {%- assign t = p | last | split: '.' | first -%} {%- comment %} title, minus file extension {% endcomment -%}
    {%- assign p = p | pop -%}                       {%- comment %} drop file part {% endcomment -%}
    {%- assign s = p | last -%}                      {%- comment %} section (containing folder) {% endcomment -%}

    {%- capture log_entry -%}"(current node) [{{l}}][{{e}}] {{s}}/{{t}} d.path: {{ d.path }}"{%- endcapture -%}{%- assign log = log | push: log_entry -%}
    {%- comment %} record node docs in visitation order {% endcomment -%}
    {%- assign guide_list = guide_list | push: d -%}

    {%- comment %} clear current node now that it's recorded {% endcomment -%}
    {%- assign curr = nil -%}

    {%- comment %} find and push next sibling in current group (if any) {% endcomment -%}
    {%- assign e1 = e | plus: 1 -%}
    {%- assign en = leveled[l].size | minus: 1 -%}
    {%- for ei in (e1..en) -%} {%- comment %} look forward from current entry's index {% endcomment -%}
      {%- assign di = leveled[l][ei] -%}
      {%- assign pi = di.path | split: '/' -%}
      {%- assign ti = pi | last | split: '.' | first -%}
      {%- assign pi = pi | pop -%}
      {%- assign si = pi | last -%}
      {%- if si == s %} {%- comment %} siblings share the same section {% endcomment -%}
        {%- comment %} ..and each higher path component needs to match, too so we don't falsely match on a separate subtree using the same names {% endcomment -%}
        {%- assign p = d.path | split: '/' -%}
        {%- assign full_match = true -%}
        {%- for i in (0..l) -%}{%- unless pi[i] == p[i] -%}{%- assign full_match = false -%}{%- break -%}{%- endunless -%}{%- endfor -%}
        {%- if full_match -%}
          {%- capture log_entry -%}"(sibling to {{t}} / stack push) [{{l}}][{{ei}}] {{si}}/{{ti}} di.path: {{ di.path }}"{%- endcapture -%}{%- assign log = log | push: log_entry -%}
          {%- assign next_item = '' | split: '' -%}
          {%- assign next_item = next_item | push: l -%}
          {%- assign next_item = next_item | push: ei -%}
          {%- assign stack = stack | push: next_item -%}
          {%- break -%}
        {%- endif -%}
      {%- endif -%}
    {%- endfor -%}

    {%- comment %} find and set curr to first matching child in next level group (if any) {% endcomment -%}
    {%- if l < max_depth -%}
      {%- assign l1 = l | plus: 1 -%}
      {%- assign ei = 0 -%} {%- comment %} start at beginning of entry group {% endcomment -%}
      {%- for di in leveled[l1] -%}
        {%- assign pi = di.path | split:'/' -%}
        {%- assign ti = pi | last | split: '.' | first -%}
        {%- assign pi = pi | pop -%}
        {%- assign si = pi | last -%}
        {%- if pi[l1] == t %} {%- comment %} children are found in directories that match their parent's title {% endcomment -%}
          {%- comment %} ..and each higher path component needs to match, too so we don't falsely match on a separate subtree using the same names {% endcomment -%}
          {%- assign p = d.path | split: '/' -%}
          {%- assign full_match = true -%}
          {%- for i in (0..l) -%}{%- unless pi[i] == p[i] -%}{%- assign full_match = false -%}{%- break -%}{%- endunless -%}{%- endfor -%}
          {%- if full_match -%}
            {%- capture log_entry -%}"(child of {{t}}) [{{l1}}][{{ei}}] {{si}}/{{ti}} di.path: {{ di.path }}"{%- endcapture -%}{%- assign log = log | push: log_entry -%}
            {%- assign curr = '' | split: '' -%}
            {%- assign curr = curr | push: l1 -%}
            {%- assign curr = curr | push: ei -%}
            {%- break -%}
          {%- endif -%}
        {%- endif -%}
        {%- assign ei = ei | plus: 1 -%}
      {%- endfor -%}
    {%- endif -%}

  {%- comment %} if no current node, pop from stack and start the loop over {% endcomment -%}
  {%- else -%}
    {%- assign curr = stack | last -%}
    {%- assign stack = stack | pop %}
    {%- capture log_entry -%}"(no entry, pop from stack)"{%- endcapture -%}{%- assign log = log | push: log_entry -%}
  {%- endif -%}
{%- endfor -%}

{% assign doc_list = guide_list %}
{% endif %}

{% for doc in doc_list %}
  {% capture link %}{{ doc.title }}{% endcapture %}
  {% capture url %}{{ doc.url }}#/{{ collection.label | downcase }}/{% endcapture %}
  {% capture item_class %}{% if doc.title == page.title %}active {% endif %}item{% endcapture %}
  {% case doc.layout %}
    {% when 'package' %}
      {% capture link %}{% include icon.liquid id='folder-outline' %} {% include package_shortener.liquid package=doc.module %}{% endcapture %}
    {% when 'type' %}
      {% capture pkg %}{{ doc.module }}.{{ doc.name }}{% endcapture %}
      {% capture link %}{% include package_shortener.liquid package=pkg %}{% endcapture %}
    {% when 'page' %}
      {% assign path_bits = doc.relative_path | split: '.' | first | split: '/' %}
      {% assign n = path_bits.size | minus: 2 %}
      {% if n > 3 %}{% assign n = 3 %}{% endif %}
      {% capture indent %}{% for i in (1..n) %}&ensp;{% endfor %}{% endcapture %}
      {% capture link %}{{ indent }}{{ doc.title }}{% endcapture %}
  {% endcase %}
  <a class="very tight smaller text {{ item_class }}" href="{{ site.baseurl }}{{ url }}">{{ link }}</a>
{% endfor %}


</div>
</div>
{% endfor %}

{% capture script_begin %}script type="text/javascript"{% endcapture %}
{% capture script_end %}/script{% endcapture %}
<{{ script_begin }}>
  {% for entry in log %}console.log({{ entry }});
  {% endfor %}
<{{ script_end }}>

<div class="ui blue horizontal label">{{ ever_last }}/{{ enough }} iterations to build guide list</div>
